# Microservices
Dieses Repository ist die Abgabe für das Projektseminar "Microservices" der HBRS.

Für jede der angeforderten Microservices wurde eine eigene Projektstruktur in dem Gesamtprojekt angelegt. So ist es möglich, dass alle Microservices in der Projektmappe eingesehen werden können. Für das Dependency-Management wurden für alle Microservices gradle verwendet. Gradle gilt als eine neuere alternative zu Maven, weil wir bei Gradle mit Ant (und Groovy) viel flexibler sind. Als Hauptframework wurde Spring Boot verwendet. Es wird der Ansatz "Konvention over Konfiguration" verwendet, der es uns ermöglicht sehr schnell lauffähige Applikationen zu erstellen. Häufig reichen dafür simple Annotationen im Code aus, aufwendige XML-Dateien zur Konfiguration fallen damit weg. Für viele der in der Anforderung geschilderten Services gibt es bei dem Framework bereits Bibliotheken, die uns eine große Menge arbeit abnehmen. 

Discovery-Service:
Als Discovery-Service wurde ein Eureka-Server verwendet. Client-basierte Service "Discovery" erlaubt es, dass die von uns erstellten Services sich gegenseitig finden und miteinander kommunizieren können, ohne das wir dabei die wichtigen Parameter, wie beispielsweise Hostname oder Port einer Anwendung vorher festschreiben müssen. Der Eureka-Server definiert dazu eine sog. "Service-Registry", bei der sich nach dem Bootvorgang jeder Service registriert. Für den Eureka-Server wurde die Abhängigkeit "spring-cloud-starter-netflix-eureka-server" hinzugefügt. Durch die Annotationen @SpringBootApplication und @EnableEurekaServer wurde die Discovery-Application zum Eureka-Server. In den Application-Properties wurde der Server-Port auf 8761, der Server-Name auf "Microservice_catalog" festgelegt. Außerdem haben wir eingestellt, dass der Server sich nicht selber als Client registriert.

Gateway-Service:
Als Gateway-Service habe ich mich für einen Service entschieden, der auf dem Netflix-Zuul-Gateway-Service basiert. Zuerst habe ich wieder die Abhängigkeiten im build.gradle-Datei spezifiziert. Mir hat dabei die Verwendung des Spring Boot Initializrs geholfen. Eingebunden werden musste u.a. die Abhängigkeit "spring-cloud-starter-netflix-zuul". Als Annotation habe ich für die Gateway-Klasse @EnableZuulProxy und @SpringBootApplication verwendet, damit der Microservice als Zuulproxy festgelegt wurde. Zusätzlich habe ich mit @EnableDiscoveryClient den Microservice als Client für den Eureka-Server festgelegt, damit dieser sich registriert und für die spätere Umgebung auffindbar wird. In der application.yml-Datei habe ich die Einstellungen konfiguriert. Als Name wurde "Zuul-Gateway" festgelegt. Der Gateway-Service ist unter dem Port 9090 ansprechbar. Anschließend wurden die Einstellungen für Eureka festgelegt, damit der Server auch gefunden werden kann. Letztlich wurde in der Konfigurationsdatei noch eine Route hinzugefügt, damit alle Anfragen die mit /helloservice beginnen und an das Gateway geschickt werden mittels des Round-Robin-Verfahrens an die Microservices geleitet werden, die im Eureka-Service mit der ServiceID "HELLOSERVICE" registriert sind.

Services:
Die Services wurden simpel gehalten, es gibt beispielsweise eine /greeting GET-Methode, bei der der Service einfach nur eine Hallo-Nachricht zurückgibt, mit einem zufälligem Wert, der für jeden Service neu generiert wird. Der zufällige Wert soll dazu dienen, dass die Services untereinander unterschieden werden können. Wenn beispielsweise mehrere Anfragen an das Gateway geschickt werden, dann kann man die Round-Robin-Lastenverteilung durch die angezeigten zufälligen Werte identifizieren. Als weitere Möglichkeit wurde eine POST-Methode /greetingJSON angelegt, die ebenfalls ein Hello mit einem zufälligem Wert zurückgibt. Der Aufbau des Service wurde dabei so gehalten, wie es in der Vorlesung vorgestellt worden ist. D.h. es gibt ein ein extra Package jeweils für das Model, View, Controller und die Services. Die Clients werden ebenfalls als Eureka-Clients betrieben, damit diese sich bei dem Eureka-Server registrieren und somit auffindbar und ansprechbar sind. Bei den Einstellungen wurde für den Port 0 angegeben, damit beim Starten der Anwendung der Port zufällig gewählt wird. Außerdem wird für bei jedem Service mit ${random.value} eine zufällige ID generiert, damit die verschiedenen Services auch voneinander unterschieden werden können, auch wenn alle die gleiche Funktionalität bereitstellen. Durch den Aufruf der GET-Methode /shutdown kann ein Service heruntergefahren werden.

Skript:
In dem Projekt gibt es einen extra Ordner skripts. Dort ist ein StarterSkript (ShellSkript) hinterlegt, dass einfach die Microservices des Projektes im Hintergrund startet und die Meldungen (sowohl Status- als auch Fehlermeldungen) auf der Konsole unterdrückt. Da ich für die Entwicklung des Projektes ein Macbook verwendet habe, habe ich ein Shellskript erstellt, welches aber mit anderen Unix-kompatiblen Betriebssystemen ebenfalls ausführbar sein sollte. In der .gitignore-Datei habe ich angegeben, dass die Ordner /build/libs/** ebenfalls in das Versionskontrollsystem hochgeladen werden, damit eine Ausführung des Startskriptes auch ohne Probleme möglich ist. In den Libs-Ordnern liegen nämlich die .jar-Dateien der einzelnen Microservices, die das Skript versucht aufzurufen. Nachdem die Services gestartet wurden und man einen Moment gewartet hat, werden sowohl 3 Clients mit der InstanceId "HELLOSERVICE" als auch das Zuul-Gateway und die Factory beim Eureka-Server angezeigt. Wenn man nun das Gateway aufruft und man die Abfrage /helloservice/greeting ausführt, wird man an die dahinterliegenden Clients weitergeleitet.
